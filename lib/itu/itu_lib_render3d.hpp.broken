#ifndef ITU_SYS_RENDER_3D_HPP
#define ITU_SYS_RENDER_3D_HPP

struct VertexData
{
	glm::vec3 position;
	glm::vec3 normal;
	glm::vec2 uv;
};

struct InstanceData
{
	glm::mat4 transform_global;
};

struct UniformData
{
	// camera
	glm::mat4 camera_view;
	glm::mat4 camera_projection;
	glm::vec3 camera_position; // we don't want to compute the position in the shader, it's the same for every pixel
	float padding0;
	// light
	glm::vec4 light_direction; // w = 1 is positional, w = 0 is directional;
	glm::vec4 light_color;

	// misc
	float time;
};

struct MeshData
{
	int vertices_count;
	int indices_count;
	int submesh_first_index_count;

	VertexData* vertices;
	int*        indices;
	int*        submesh_first_index;  // index of the first index of the i-th submesh (in the `indices` array above)

	// gpu data
	int gpu_offset_vertices;
	int gpu_offset_indices;
};

// enough space for 32768 verties (pos, normal, uvs)
#define VERTEX_DATA_SIZE_MAX   KB(512)

// enough space for 131072
#define INDEX_DATA_SIZE_MAX    KB(256)

// enough space for 4096 transforms
#define INSTANCE_DATA_SIZE_MAX KB(256)

// enough for... anything? (TBH probably too much but whatever)
#define UNIFORM_DATA_SIZE_MAX  KB(1)

// enough space for 4 texture with
// - 4k size
// - 4 channels
// - 1 byte per channel
#define TEXTURE_DATA_SIZE_MAX  MB(128)

void itu_sys_render3d_init(SDLContext* context);
MeshData* itu_sys_render3d_load_mesh(const char* path);

void itu_sys_render3d_frame_begin(SDLContext* context);
void itu_sys_render3d_mesh_render(SDLContext* context, MeshData* data, glm::mat4 transform);
void itu_sys_render3d_mesh_render_instanced(SDLContext* context, MeshData* data, InstanceData* instances, int instances_count);
void itu_sys_render3d_frame_end(SDLContext* context);

#endif // ITU_RENDER_3D_HPP


// TMP
#define ITU_SYS_RENDER_3D_IMPLEMENTATION
#if (defined ITU_SYS_RENDER_3D_IMPLEMENTATION) || (defined ITU_UNITY_BUILD)

#ifndef ITU_UNITY_BUILD
#include <assimp/scene.h>
#include <assimp/cimport.h>
#include <assimp/postprocess.h>

#endif
#define UNIFORM_SLOT_GLOBAL   0
#define UNIFORM_SLOT_MATERIAL 1

struct ITU_SysRender3DCtx
{
	SDL_GPUDevice* device;
	SDL_GPUGraphicsPipeline* pipeline;
	SDL_GPUColorTargetInfo color_target_info;
	SDL_GPUDepthStencilTargetInfo depth_stencil_target_info;
	SDL_GPUTexture* depth_stencil_texture;
	SDL_GPUTexture* color_texture;

	UniformData uniform_data_global;

	SDL_GPUCommandBuffer* command_buffer_upload;
	SDL_GPUCommandBuffer* command_buffer_render;

	// very simple pattern consisting of persistent buffers only. not very performant but simple to implement
	SDL_GPUTransferBuffer* transfer_buffer;
	SDL_GPUTransferBuffer* transfer_buffer_texture;
	SDL_GPUBuffer* buf_data;
	SDL_GPUBuffer* buf_data_texture;
	Uint8* mapping_data;
	Uint8* mapping_data_texture;

	// gpu data offsets
	int base_offset_vertices;
	int base_offset_indices;
	int base_offset_texture;
	int curr_offset_vertices;
	int curr_offset_indices;
	int curr_offset_texture;

	// TMP renderpass
	SDL_GPURenderPass* render_pass;
};
static ITU_SysRender3DCtx ctx_rendering;

struct Material
{
	SDL_GPUShader* shader_base_vert;
	SDL_GPUShader* shader_base_frag;

	SDL_GPUTextureSamplerBinding texture_bindings;

	SDL_GPUTexture* tex_albedo;
	ITU_IdRawTexture tex_albedo_data;
};

// TMP testing material to check 3D rendering capabilities
//     materials will be resources like everything else, but it requires still a bit of design work
static Material TMP_material_phong;

// private functions
SDL_GPUShader* shader_load(const char* path, SDL_GPUShaderStage stage, int num_uniform_buffers, int num_samples);
void acquare_basic_resources(SDLContext* context);
SDL_GPUTexture* gpu_texture_create(SDL_GPUDevice* device, int w, int h, int channels, SDL_GPUTextureUsageFlags usage, SDL_GPUTextureFormat format);
void create_persistent_buffer(SDL_GPUTransferBuffer* buffer_transfer, Uint32 size, SDL_GPUBuffer** out_buffer, Uint8** out_memory, const char* name);

void itu_sys_render3d_init(SDLContext* context)
{
	// try to use vulkan
	// TODO test on mac, need to be sure that it will fallback to metal if needed!
	ctx_rendering.device = SDL_CreateGPUDevice(SDL_GPU_SHADERFORMAT_SPIRV, true, "vulkan");
	SDL_ClaimWindowForGPUDevice(ctx_rendering.device, context->window);

	// create temporary material
	{
		ITU_IdRawTexture id_tex = itu_sys_rstorage_raw_texture_load(context, "data/kenney/meshes/Textures/colormap.png");
		RawTextureData* tex_data = itu_sys_rstorage_raw_texture_get_ptr(id_tex);
		TMP_material_phong.shader_base_vert = shader_load("data/shader/phong.vert.spv", SDL_GPU_SHADERSTAGE_VERTEX  , 1, 0);
		TMP_material_phong.shader_base_frag = shader_load("data/shader/phong.frag.spv", SDL_GPU_SHADERSTAGE_FRAGMENT, 1, 1);
		TMP_material_phong.tex_albedo = gpu_texture_create(ctx_rendering.device, tex_data->width, tex_data->height, 4, SDL_GPU_TEXTUREUSAGE_SAMPLER, SDL_GPU_TEXTUREFORMAT_R8G8B8A8_UNORM)
;		TMP_material_phong.texture_bindings.texture = TMP_material_phong.tex_albedo;
		{
			SDL_GPUSamplerCreateInfo create_info = { };
			TMP_material_phong.texture_bindings.sampler = SDL_CreateGPUSampler(ctx_rendering.device, &create_info);
		}
	}

	acquare_basic_resources(context);

	{
		SDL_GPUTransferBufferCreateInfo create_info = { };
		create_info.usage = SDL_GPU_TRANSFERBUFFERUSAGE_UPLOAD;
		create_info.size = VERTEX_DATA_SIZE_MAX;
		ctx_rendering.transfer_buffer = SDL_CreateGPUTransferBuffer(ctx_rendering.device, &create_info);
	}
	{
		SDL_GPUTransferBufferCreateInfo create_info = { };
		create_info.usage = SDL_GPU_TRANSFERBUFFERUSAGE_UPLOAD;
		create_info.size = TEXTURE_DATA_SIZE_MAX;
		ctx_rendering.transfer_buffer_texture = SDL_CreateGPUTransferBuffer(ctx_rendering.device, &create_info);
	}
	create_persistent_buffer(ctx_rendering.transfer_buffer, VERTEX_DATA_SIZE_MAX + INDEX_DATA_SIZE_MAX + INSTANCE_DATA_SIZE_MAX, &ctx_rendering.buf_data, &ctx_rendering.mapping_data, "transfer");
	create_persistent_buffer(ctx_rendering.transfer_buffer_texture, TEXTURE_DATA_SIZE_MAX, &ctx_rendering.buf_data_texture, &ctx_rendering.mapping_data_texture, "transfer_texture");
	ctx_rendering.base_offset_vertices = 0;
	ctx_rendering.base_offset_indices = ctx_rendering.base_offset_vertices + VERTEX_DATA_SIZE_MAX;
	ctx_rendering.base_offset_texture = 0;

	
	SDL_SetGPUBufferName(ctx_rendering.device, (SDL_GPUBuffer*)ctx_rendering.buf_data, "ctx_rendering.buf_data");
	SDL_SetGPUBufferName(ctx_rendering.device, (SDL_GPUBuffer*)ctx_rendering.buf_data_texture, "ctx_rendering.buf_data_texture");
	SDL_SetGPUBufferName(ctx_rendering.device, (SDL_GPUBuffer*)ctx_rendering.transfer_buffer, "ctx_rendering.transfer_buffer");
	SDL_SetGPUBufferName(ctx_rendering.device, (SDL_GPUBuffer*)ctx_rendering.transfer_buffer_texture, "ctx_rendering.transfer_buffer_texture");
}

Uint32 gpu_data_upload(void* dst, Uint32 dst_offset, const void* src, int src_size, Uint32 src_offset, SDL_GPUCopyPass* copy_pass)
{
	// upload (pointer, size) to the given persistently-mapped buffer
	// we will use this for vertex, index and instance data
	//Uint8* ptr_data_vertex = pointer_offset(Uint8, ctx_rendering.mapping_data, ctx_rendering.curr_offset_vertices);
	SDL_memcpy(dst, pointer_offset(void, src, src_offset), src_size);
	SDL_GPUTransferBufferLocation transfer_buffer_location = { };
	transfer_buffer_location.offset = src_offset;
	transfer_buffer_location.transfer_buffer = ctx_rendering.transfer_buffer;

	SDL_GPUBufferRegion transfer_buffer_destination = { };
	transfer_buffer_destination.buffer = ctx_rendering.buf_data;
	transfer_buffer_destination.offset = dst_offset;
	transfer_buffer_destination.size = src_size;

	SDL_UploadToGPUBuffer(
		copy_pass,
		&transfer_buffer_location,
		&transfer_buffer_destination,
		true
	);

	return dst_offset + src_size;
}
MeshData* itu_sys_render3d_load_mesh(const char* path)
{
	const aiScene* scene = aiImportFile(path, aiPostProcessSteps::aiProcess_Triangulate | aiPostProcessSteps::aiProcess_FlipUVs);

	int submeshes_count = scene->mNumMeshes;
	int vertices_count = 0;
	int indices_count  = 0; 

	for(int i = 0; i < scene->mNumMeshes; ++i)
	{
		aiMesh* mesh = scene->mMeshes[i];
		vertices_count += mesh->mNumVertices;
		// NOTE: we are asking assimp to triangulate the mesh after loading it, so we are safe to assume all faces are triangular!
		indices_count += 3 * mesh->mNumFaces;
	}

	size_t vertex_array_size = sizeof(VertexData) * vertices_count;
	size_t index_array_size = sizeof(int) * vertices_count;
	size_t submesh_first_element_array_size = sizeof(int) * vertices_count;
	size_t tota_data_size =
		sizeof(MeshData) +
		vertex_array_size +
		index_array_size + 
		submesh_first_element_array_size;
	MeshData* ret = (MeshData*)SDL_malloc(tota_data_size);
	ret->vertices             = pointer_offset(VertexData, ret, sizeof(MeshData));
	ret->indices              = pointer_offset(int, ret->vertices, vertex_array_size);
	ret->submesh_first_index  = pointer_offset(int, ret->indices , submesh_first_element_array_size);

	ret->vertices_count = vertices_count;
	ret->indices_count  = vertices_count;
	ret->submesh_first_index_count  = submeshes_count;

	int curr_index = 0;
	int curr_vertex = 0;
	for(int i = 0; i < scene->mNumMeshes; ++i)
	{
		aiMesh* mesh = scene->mMeshes[i];
		
		// slices
		ret->submesh_first_index[i] = curr_index;

		// vertices
		for(int j = 0; j < mesh->mNumVertices; ++j)
		{
			ret->vertices[curr_vertex].position = value_cast(glm::vec3, mesh->mVertices[j]);
			ret->vertices[curr_vertex].normal   = value_cast(glm::vec3, mesh->mNormals[j]);
			ret->vertices[curr_vertex].uv       = value_cast(glm::vec2, mesh->mTextureCoords[0][j]);
			++curr_vertex;
		}
		
		// indices
		for(int j = 0; j < mesh->mNumFaces; ++j)
		{
			ret->indices[curr_index++] = mesh->mFaces[j].mIndices[0];
			ret->indices[curr_index++] = mesh->mFaces[j].mIndices[1];
			ret->indices[curr_index++] = mesh->mFaces[j].mIndices[2];
		}
	}

	// TMP
	SDL_Log("loaded %s", path);
	SDL_Log("\tcount vertices  : %d", ret->vertices_count);
	SDL_Log("\tcount indices   : %d", ret->indices_count);
	SDL_Log("\tcount submeshes : %d", ret->submesh_first_index_count);
	SDL_Log("\tsize vertex data: %d", sizeof(ret->vertices[0]) * ret->vertices_count);
	SDL_Log("\tsize index  data: %d", sizeof(ret->indices[0]) * ret->indices_count);
	SDL_Log("\tsize total      : %d", sizeof(ret));

	// upload to GPU
	SDL_assert(ctx_rendering.curr_offset_vertices + vertex_array_size <= VERTEX_DATA_SIZE_MAX);
	SDL_assert(ctx_rendering.curr_offset_indices + index_array_size <= INDEX_DATA_SIZE_MAX);

	// copy data to gpu
	{
		ctx_rendering.command_buffer_upload = SDL_AcquireGPUCommandBuffer(ctx_rendering.device);
		SDL_GPUCopyPass* copy_pass = SDL_BeginGPUCopyPass(ctx_rendering.command_buffer_upload);

		// upload vertex and index data
		{
			void* transfer = ctx_rendering.mapping_data;
			Uint32 transfer_offset = 0;
			transfer_offset += gpu_data_upload(
				transfer,
				ctx_rendering.base_offset_vertices + ctx_rendering.curr_offset_vertices,
				ret->vertices,
				vertex_array_size,
				transfer_offset,
				copy_pass
			);
			transfer_offset += gpu_data_upload(
				pointer_offset(void, transfer, transfer_offset),
				ctx_rendering.base_offset_indices  + ctx_rendering.curr_offset_indices,
				ret->indices,
				index_array_size,
				transfer_offset,
				copy_pass
			);
			
			SDL_EndGPUCopyPass(copy_pass);
			VALIDATE_PANIC(SDL_SubmitGPUCommandBufferAndAcquireFence(ctx_rendering.command_buffer_upload));
		}
	}

	return ret;
}

void itu_sys_render3d_frame_begin(SDLContext* context)
{
	SDL_WaitAndAcquireGPUSwapchainTexture(
		ctx_rendering.command_buffer_render,
		context->window,
		&ctx_rendering.color_target_info.texture,
		NULL,
		NULL
	);

	ctx_rendering.render_pass = SDL_BeginGPURenderPass(ctx_rendering.command_buffer_render, &ctx_rendering.color_target_info, 1, &ctx_rendering.depth_stencil_target_info);
	
	SDL_BindGPUGraphicsPipeline(ctx_rendering.render_pass, ctx_rendering.pipeline);
	
	SDL_GPUViewport viewport = { 0 };
	SDL_FRect viewport_rect = camera_get_viewport_rect(context, context->camera_active);
	viewport.x = viewport_rect.x;
	viewport.y = viewport_rect.y;
	viewport.w = viewport_rect.w;
	viewport.h = viewport_rect.h;
	viewport.min_depth = 0;
	viewport.max_depth = 1;
	SDL_SetGPUViewport(ctx_rendering.render_pass, &viewport);
}

void itu_sys_render3d_mesh_render(SDLContext* context, MeshData* data, glm::mat4 transform)
{
	Uint32 size_vertices = sizeof(VertexData) * data->vertices_count;
	Uint32 size_indices = sizeof(int) * data->indices_count;
	Uint32 size_instance = sizeof(glm::mat4);
	Uint32 size_total = size_vertices + size_indices + size_instance;

	Uint32 offset_vertices = 0;
	Uint32 offset_indices = offset_vertices + size_vertices;
	Uint32 offset_instance = offset_indices + size_indices;

	SDL_GPUBufferBinding bindings_vertex[2] = 
	{
		{ ctx_rendering.buf_data, offset_vertices },
		{ ctx_rendering.buf_data, offset_instance }
	};
	SDL_GPUBufferBinding bindings_indices = { ctx_rendering.buf_data, offset_indices };

	SDL_PushGPUVertexUniformData(ctx_rendering.command_buffer_render, 0, &ctx_rendering.uniform_data_global, sizeof(UniformData));

	SDL_BindGPUVertexBuffers(ctx_rendering.render_pass, 0, bindings_vertex, 2);

	SDL_BindGPUIndexBuffer(ctx_rendering.render_pass, &bindings_indices, SDL_GPU_INDEXELEMENTSIZE_32BIT);

	SDL_BindGPUFragmentSamplers(ctx_rendering.render_pass, 0, &TMP_material_phong.texture_bindings, 1);
		
	int num_indices   = data->vertices_count;

	//VALIDATE_PANIC(SDL_WaitForGPUFences(ctx_rendering.device, true, &fence_upload, 1));
	SDL_DrawGPUIndexedPrimitives(
		ctx_rendering.render_pass,
		data->indices_count,
		1,
		0,
		0,
		0
	);

}

void itu_sys_render3d_mesh_render_instanced(MeshData* data, InstanceData* instances, int instances_count)
{

}

void itu_sys_render3d_frame_end(SDLContext* context)
{
	SDL_EndGPURenderPass(ctx_rendering.render_pass);

	//SDL_WaitForGPUFences(ctx_rendering.device, true, &fence_upload, 1);
	VALIDATE_PANIC(SDL_SubmitGPUCommandBuffer(ctx_rendering.command_buffer_render));
	//VALIDATE_PANIC(ctx_rendering.render_fence = SDL_SubmitGPUCommandBufferAndAcquireFence(ctx_rendering.command_buffer_render));
}
// =====================================================================================
// private functions
// =====================================================================================

SDL_GPUShader* shader_load(const char* path, SDL_GPUShaderStage stage, int num_uniform_buffers, int num_samplers)
{
	size_t shader_code_vert_size;
	void* shader_code_vert = SDL_LoadFile(path, &shader_code_vert_size);
	SDL_GPUShaderCreateInfo shader_base_def = { };
	shader_base_def.code = (Uint8*)shader_code_vert;
	shader_base_def.code_size = shader_code_vert_size;
	shader_base_def.entrypoint = "main";
	shader_base_def.format = SDL_GPU_SHADERFORMAT_SPIRV;
	shader_base_def.stage = stage;
	shader_base_def.num_uniform_buffers = num_uniform_buffers;
	shader_base_def.num_samplers = num_samplers;
	return SDL_CreateGPUShader(ctx_rendering.device, &shader_base_def);
}

void acquare_basic_resources(SDLContext* context)
{
	// vertex buffer descriptors
	SDL_GPUVertexBufferDescription shader_base_vert_vertex_buffer_descriptions[] =
	{
		{
			.slot = 1,
			.pitch = sizeof(InstanceData),
			.input_rate = SDL_GPU_VERTEXINPUTRATE_INSTANCE,
		},
		{
			.slot = 0,
			.pitch = sizeof(VertexData),
			.input_rate = SDL_GPU_VERTEXINPUTRATE_VERTEX
		}
	};

	// vertex attribute descriptors
	SDL_GPUVertexAttribute shader_base_vert_vertex_attributes[] = 
	{
		// position
		{
			.location = 0,
			.buffer_slot = 0,
			.format = SDL_GPU_VERTEXELEMENTFORMAT_FLOAT3,
			.offset = offsetof(VertexData, position)
		},
		// normal
		{
			.location = 1,
			.buffer_slot = 0,
			.format = SDL_GPU_VERTEXELEMENTFORMAT_FLOAT3,
			.offset = offsetof(VertexData, normal)
		},
		// uv
		{
			.location = 2,
			.buffer_slot = 0,
			.format = SDL_GPU_VERTEXELEMENTFORMAT_FLOAT2,
			.offset = offsetof(VertexData, uv)
		},
		// instance transform - col 0
		{
			.location = 3,
			.buffer_slot = 1,
			.format = SDL_GPU_VERTEXELEMENTFORMAT_FLOAT4,
			.offset = offsetof(InstanceData, transform_global) + sizeof(float[4]) * 0
		},
		// instance transform - col 1
		{
			.location = 4,
			.buffer_slot = 1,
			.format = SDL_GPU_VERTEXELEMENTFORMAT_FLOAT4,
			.offset = offsetof(InstanceData, transform_global) + sizeof(float[4]) * 1
		},
		// instance transform - col 2
		{
			.location = 5,
			.buffer_slot = 1,
			.format = SDL_GPU_VERTEXELEMENTFORMAT_FLOAT4,
			.offset = offsetof(InstanceData, transform_global) + sizeof(float[4]) * 2
		},
		// instance transform - col 3
		{
			.location = 6,
			.buffer_slot = 1,
			.format = SDL_GPU_VERTEXELEMENTFORMAT_FLOAT4,
			.offset = offsetof(InstanceData, transform_global)  + sizeof(float[4]) * 3
		},
	};

	ctx_rendering.depth_stencil_texture = gpu_texture_create(ctx_rendering.device, context->window_w, context->window_h, 1, SDL_GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET, SDL_GPU_TEXTUREFORMAT_D24_UNORM);
	ctx_rendering.color_texture = gpu_texture_create(ctx_rendering.device, context->window_w, context->window_h, 1, SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, SDL_GPU_TEXTUREFORMAT_R8G8B8A8_UNORM);

	SDL_GPUColorTargetDescription color_target_descriptions = { };
	color_target_descriptions.format = SDL_GetGPUSwapchainTextureFormat(ctx_rendering.device, context->window);
	color_target_descriptions.blend_state.enable_blend = true;
	color_target_descriptions.blend_state.alpha_blend_op = SDL_GPU_BLENDOP_ADD;
	color_target_descriptions.blend_state.color_blend_op = SDL_GPU_BLENDOP_ADD;
	color_target_descriptions.blend_state.dst_alpha_blendfactor = SDL_GPU_BLENDFACTOR_ONE_MINUS_SRC_ALPHA;
	color_target_descriptions.blend_state.src_alpha_blendfactor = SDL_GPU_BLENDFACTOR_SRC_ALPHA;
	color_target_descriptions.blend_state.dst_color_blendfactor = SDL_GPU_BLENDFACTOR_ONE_MINUS_SRC_ALPHA;
	color_target_descriptions.blend_state.src_color_blendfactor = SDL_GPU_BLENDFACTOR_SRC_ALPHA;

	SDL_GPUGraphicsPipelineCreateInfo pipeline_def = { };
	pipeline_def.vertex_shader = TMP_material_phong.shader_base_vert;
	pipeline_def.fragment_shader = TMP_material_phong.shader_base_frag;
	pipeline_def.vertex_input_state.vertex_buffer_descriptions = shader_base_vert_vertex_buffer_descriptions;
	pipeline_def.vertex_input_state.num_vertex_buffers = array_size(shader_base_vert_vertex_buffer_descriptions);
	pipeline_def.vertex_input_state.vertex_attributes = shader_base_vert_vertex_attributes;
	pipeline_def.vertex_input_state.num_vertex_attributes = array_size(shader_base_vert_vertex_attributes);
	pipeline_def.primitive_type = SDL_GPU_PRIMITIVETYPE_TRIANGLELIST;
	pipeline_def.target_info = SDL_GPUGraphicsPipelineTargetInfo
	{
		.color_target_descriptions = &color_target_descriptions,
		.num_color_targets = 1,
		.depth_stencil_format = SDL_GPU_TEXTUREFORMAT_D24_UNORM,
		.has_depth_stencil_target = true
	};

	ctx_rendering.pipeline = SDL_CreateGPUGraphicsPipeline(ctx_rendering.device, &pipeline_def);
	
	ctx_rendering.depth_stencil_target_info.clear_depth = true;
	ctx_rendering.depth_stencil_target_info.clear_stencil = true;
	ctx_rendering.depth_stencil_target_info.cycle = true;
	ctx_rendering.depth_stencil_target_info.load_op = SDL_GPU_LOADOP_CLEAR;
	ctx_rendering.depth_stencil_target_info.stencil_load_op = SDL_GPU_LOADOP_CLEAR;
	ctx_rendering.depth_stencil_target_info.stencil_store_op = SDL_GPU_STOREOP_DONT_CARE;
	ctx_rendering.depth_stencil_target_info.store_op = SDL_GPU_STOREOP_DONT_CARE;
	ctx_rendering.depth_stencil_target_info.texture = ctx_rendering.depth_stencil_texture;

	ctx_rendering.color_target_info = { };
	ctx_rendering.color_target_info.clear_color = SDL_FColor{ 1, 0, 0, 0 };
	ctx_rendering.color_target_info.store_op = SDL_GPU_STOREOP_STORE;
	ctx_rendering.color_target_info.load_op = SDL_GPU_LOADOP_CLEAR;
	ctx_rendering.color_target_info.cycle = true;
	ctx_rendering.color_target_info.texture = ctx_rendering.color_texture;

}

SDL_GPUTexture* gpu_texture_create(SDL_GPUDevice* device, int w, int h, int channels, SDL_GPUTextureUsageFlags usage, SDL_GPUTextureFormat format)
{
	SDL_GPUTextureCreateInfo create_info = { };
	create_info.format = format;
	create_info.width = w;
	create_info.height = h;
	create_info.layer_count_or_depth = 1;
	create_info.num_levels = 1;
	create_info.type = SDL_GPU_TEXTURETYPE_2D;
	create_info.usage = usage;

	SDL_GPUTexture* ret;
	VALIDATE(ret = SDL_CreateGPUTexture(device, &create_info));
	return ret;
}

void create_persistent_buffer(SDL_GPUTransferBuffer* buffer_transfer, Uint32 size, SDL_GPUBuffer** out_buffer, Uint8** out_memory, const char* name)
{
	SDL_GPUBufferCreateInfo create_info = { };
	create_info.usage = SDL_GPU_BUFFERUSAGE_VERTEX | SDL_GPU_BUFFERUSAGE_INDEX; // TMP FIXME this is not correct, find the correct usage type
	create_info.size = size;
	*out_buffer = SDL_CreateGPUBuffer(ctx_rendering.device, &create_info);
	VALIDATE(*out_buffer);
	*out_memory = (Uint8*)SDL_MapGPUTransferBuffer(ctx_rendering.device, buffer_transfer, true);
	VALIDATE(*out_memory);
}

#undef UNIFORM_SLOT_GLOBAL
#undef UNIFORM_SLOT_MATERIAL

#endif // (defined ITU_SYS_RENDER_3D_IMPLEMENTATION) || (defined ITU_UNITY_BUILD)
